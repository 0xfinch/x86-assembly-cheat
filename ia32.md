# IA-32

# x86

Instruction set that dominates the desktop market on Windows, Mac and Linux.

The official name is IA-32 commonly known as x86 or x86-32 or i386.

This section shall contain info on the entire family.

Majority of PCs use it as of 2013. Cell phones use ARM mainly.

AMD also produces CPUs with a compatible interface.

CISC.

Backwards compatible to the 1970s!

## Implementations

Intel and AMD are the major ones.

Cyrix was an implementor before being bought by National Semiconductor, and VIA continue to produce them after buying Cyrix from NS.

## Sources

-   [IA-32 manual](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)

    Intel man pages, *the* official source.

    Also includes Intel 64.

    Interesting sections:

    - Vol 1 5: instruction overview. In particular, groups instructions logically.
    - Vol 2 3: full instruction listing and API.

-   [Wikipedia Instruction List](http://en.wikipedia.org/wiki/X86_instruction_listings)

    Instruction list.

## Intel processor history

Important to understand instruction set names used until today.

### Intel 8080

1974, 8 bit, 2MHz, very popular

### Intel 8086

1976, 16 bit, very popular, base to x86 language

### Intel 80386

aka i386

1985, 32 bit word register

### Intel 8087

1980

External floating point co-processor for the 8086.

In other words: this is not a CPU, but something external to the CPU, which the CPU could interface with.

Included inside CPUs starting from the 80436

x87 often used to describe the floating point operations inside the processors

Instructions include:

- FSQRT
- FSIN

### Intel 80486

1989

Includes floating point unity inside of it

### Intel Core

Generic Intel branding since 2007.

### i3

### i5

### i7

Generic branding by Intel since 2010.

They just mean low, mid and high end, nothing else is implied, not even the number of cores.

A much more meaningful way to group the processors is by the architecture, e.g. Ivy Bridge, Haswell, etc.

## Syntaxes

There is no de facto standard for the computer syntax

### Intel

Used to document Intel x86 at first

More popular on windows

Used by NASM and MASM.

#### AT&T

More popular for Linux, since UNIX was created at bell labs,

## Pinout

It is a good idea to understand what are the physical pins of the processor and what they do to understand what is actually going on when you do instructions

![8086 pinout a](8086-pinout.gif "8086 pinout")

![80387 pinout a](80387-pinout.gif "80387 pinout")

TODO understand

## Registers

Registers store data in the processor.

Most CPU operations operate on and or use registers values.

There are very few registers compared to RAM slots because of the memory hierarchy tradeoff: CPU register access is extremely fast, but the cost of each register is extremely high.

Suffixes:

- B: byte
- W: word = 2 bytes
- D: double word = 2 words (a c `int`)
- Q: quad word
- T: ten bytes

### access modes

For 32 bit registers, most instructions allow to operate on either:

- 32 bits. Called extended. ex: `eax`
- 16 lower bits. E.g.: `ax`
- 8 lower bits. `al`
- 8 upper bits. `au`

### general purpose registers

There are 8 general-purpose 32 bit registers (`gpr`):

- EAX
- EBX
- ECX
- EDX
- ESI
- EDI
- EBP
- ESP: used stack pointer.

In theory, those can be used freely for many computations such as sums, subtractions, etc.

However, some instructions make extensive use of certain of those registers such as `ESP` which keeps track of the stack.

Therefore, you should rely primarily on `eax`, `ebx` and `ecx` as actually being general purpose, and even for those you should check often if each operation will not take input/output from them without you knowing it.

### Flags register

Each bit represents a boolean

Types:

- FLAGS: 16 lower bits
- EFLAGS: (extended) refers to the 16 upper bits only, or the entire register

Some of those values may be modified as of by other operations such as comparisons or sums, to indicate certain conditions

Some of the flags are:

- SF sign

- ZF zero

1 if result == 0

- PF parity

0 lower 8 bits of result

- CF carry

- OF overflow

- AF adjust

- IF interrupt flag

This flag says if interrupts are enabled or disabled in the current processor

This can be useful for synchronization

It can only be set / cleared by a processes with sufficient privileges normally one that runs in kernel space, such as kernel code of as a Linux kernel module

For that reason, its usage cannot be demonstrated here, but only in an OS depend ant manner.

All flags can be identified by a single letter. Ex: zero flag Z, sign flag S.

#### Flag instructions

Flags have the following operations defined

- clear: clX.  flag = 0
- set: stX.    flag = 1
- complement: cmX.    flag = !flag

All flags also have short jump instructions:

- jX:  jump if X == 1
- jnX: jump if X == 0

### Segment instruction pointer register

A 32 bit segment instruction pointer called EIP.

Points to the address of the next instruction to be executed.

Is normally increased by 4 bytes after the execution of each instruction.

It can be read by use applications.

### Segment registers

They are usually only useful for operating system writers, and can only be modified when in kernel mode.

See [this](#segmentation) for an explanation of what those do.

User level programs usually do not have permission to modify those registers.

- 6 16 bit segment registers

    - SS: start of stack segment
    - DS: start of data segment
    - CS: start of code segment
    - ES, FG, GS: are free for programs to define.

Each segment register has a corresponding read only 8 byte Segment descriptor register, which automatically pulled in from RAM when a segment is changed.

### CR registers

Control registers, CR0 to CR4.

Usually not accessible by user applications, only kernel mode.

Control very important parameters of the mode of operation of the processor.

Their exact functions may be too complicated to describe here, and will be left for other sections.

#### CR0

1 bit flags that determine how the CPU operates.

Some interesting flags are:

- 31. PG. Paging. If 1, enable paging and use the CR3 register, else disable paging.
- 30. CD. Cache disable. Globally enables/disable the memory cache.
- 29. NW. Not-write through. Globally enables/disable write-back caching.
- 18. AM. Alignment mask. Alignment check enabled if AM set, AC flag (in EFLAGS register) set, and privilege level is 3.
- 16. WP. Write protect. Determines whether the CPU can write to pages marked read-only.
- 0. PE. Protected Mode Enable. If 1, system is in protected mode, else system is in real mode.

#### CR1

Reserved by Intel for future use.

#### CR2

Used by the paging system.

After a segmentation fault, stores the value of the address access attempt that caused the fault.

#### CR3

Used by the paging system.

Points to the current Page Table, Directory, or Pointer table depending on the values of PAE and PSE.

#### CR4

1 bit flags that determine how the CPU operates.

Some of the flags are:

- 5 PAE. Physical Address Extension. If set, changes page table layout to translate 32-bit virtual addresses into extended 36-bit physical addresses.
- 4 PSE. Page Size Extension. If unset, page size is 4 KB, else page size is increased to 4 MB (or 2 Mob with PAE set).

### Other registers

- FPU registers for floating point operations
- SIMD registers MMX and XMM for SIMD instructions

## Rings

IA-32 implements a hardware protection privilege system.

There are in total 4 privilege levels, also called rings, from 0 to 3, but most operating systems use only 2: kernel space and user space, usually with values 0 and 3.

Rings are useful for OS programmers. The OS lets user programs run a restricted set of operations limiting the amount of damage that a badly working or badly intentioned program can do. Obviously this only works because user programs are then in a state in which they cannot modify their own privilege levels without the OS intervening.

Certain operations such are only allowed if certain privileges are given.

Privilege control is only available on protected mode, and is managed by segmentation and paging.

## Real mode

The other memory operation mode besides protected mode

## Protected mode

Is the normal mode of operation.

The other main mode is called real mode, which exists mainly for backwards compatibility.

The processor starts on real mode only for backwards compatibility.

Starting from 386, mode is determined by the `PE` (protect enable) bit of the CR0 register. If set, protected mode is active. If clear, real mode is active.

Protected mode furnishes two things: memory segmentation and paging.

Those two features are basic to modern operating system implementations.

The hardware supports these two feature to make it faster, and automatically interacts with data stored on RAM when needed.

Before entering protected mode, the software must first set up the required RAM data.

## Address types

There are 3 types:

- logical
- linear
- physical

### Logical address

A 16 bit segment + a 32 bit offset.

With segmentation, can be translated to a 32 bit address only.

### Linear address

32 bit address, may be modified by paging before translation to a physical address.

### Physical address

The actual electrical signals that go on the address memory cable.

## Cache

### Cache sources

-   [Stallings - 2011 - Operating-Systems-Internals](http://www.amazon.com/Operating-Systems-Internals-Principles-Edition/dp/013230998X) section "Cache Memory"

    Small and good introduction to the subject.

### Associativity

TODO

### Write back policy

-   write through: always write to RAM immediately. Not efficient.

-   not write through: writes to  RAM can happen only when the cache content is about to be invalidated.

    RAM remains on an outdated state for some time, which may lead to concurrency issues.

The policy can be controlled via the `NR` bit of `cr0`.

## Segmentation

Only available on protected mode.

Makes the transition from logical to linear addresses. Linear addresses are then converted to physical addresses (those that go to RAM wires) by the paging circuits.

Its usage is obligatory on protected mode.

This feature was meant to be used to implement process virtual memory spaces, but this usage has been mostly supplanted by a later implemented feature called paging. In Linux for example, only two segments are used at all times: one for the kernel, and one for all user processes.

### Hardware implementation

Segmentation hardware uses RAM data structures called the global and local segment descriptor tables (GDT and LDT).

The format of those data structures is fixed *by the hardware*, but it is up to the OS to set up and manage those data structures on RAM correctly, and to tell the hardware where to find them (via the `gdtr` and `ldtr` registers and the `lgdt` and `lldt` instructions).

Segmentation could be implemented in software but is hardware implemented because paging operations are done at every single memory access and therefore need to be very fast.

### Global descriptor table

RAM data structure that holds segment information.

The segment information data structure is called a *segment descriptor*.

Each segment descriptor is identified and retrieved via a *segment selector* structure.

### Segment selector

A segment selector is a 16 bit structure that identifies the current segment descriptor and the current privilege level.

It has the following fields:

-   index: 13 bits to identify the Segment descriptor within the current table.

    There can therefore be up to 2^13 segment descriptors on a table.

    The current table is determined by the values of `gdtr` and `ldtr` registers and by the TI bit of the segment selector.

-   RPL: Request privilege level.

    The privilege level of the code that will execute a Code segment.

-   TI: 1 bit table indicator. If set, indicates that this is a local descriptor table.

    Otherwise, it is a global descriptor table.

### Segment descriptor

Segment descriptors are kept in RAM, and are used by the hardware to translate logic to linear addresses.

It is up to the OS to set up and maintain segment descriptors on the RAM, and to inform the hardware of its location via the `gdtr` and `ldtr` registers The OS can modify those registers via the `lgdt` and `lldt` instructions.

Segment descriptors are kept inside tables which contain many contiguous segment descriptors called either global descriptor table or local descriptor table.

Each segment descriptor is 8 bytes long, and contains information such as the following.

-   BASE: 32 bit start address and end address of the segment

-   LIMIT: 20 bit segment length. This is multiplied by $2^12$ if G is set so the maximum length is 4GB ($2^32$).

    Minimum length is 4 Kb.

-   G: granularity flat. If set, LIMIT is in multiples of $2^12$ bytes, else multiples of 1 byte.

-   DPL: 2 bit privilege level.

    Compared to the privilege level of the Segment Selector to determine if users have or not permission to take certain actions ( the rings are based on this )

-   Type: 4 bit type field. Some of the types are:

    - Code: indicates a code segment. It is on this case the permissions to take actions are checked.

    - Data:

    - TSSD: task state segment descriptor. The segment contains saved register values (between process sleeps)

    - LDTD: the segment contains a local descriptor table

-   S: system

    If set, indicates that the RAM of that segment contains important structures such as Local descriptor table.

The current segment descriptor is determined
by the current segment selector and the values of the `gdtr` and `ldtr` registers.

### Segment registers

Segment registers contain segment selectors

There are 6 segment registers.

3 have special meanings:

- CS: code segment
- SS: data segment
- DS: data segment

And the other three don't and are free for programmer use.

- ES
- FG
- GS

Segment selectors can be put into those segment registers via `mov` instructions.

Each segment selector has an associated read only register which contains the corresponding segment descriptor to that selector.

Segment descriptors are pulled into dedicated processor registers automatically when a segment register changes value.

This allows to read segment descriptors from RAM only once when segments change, and access them directly from the CPU the following times.

TODO which of those segments are used at each time?

### Segment descriptor types

TODO what is the difference between types?

### Example of address translation

TODO very important. One example, two programs running. Logical to linear address translation.

### Linux

TODO How Linux uses segments.

## Interrupts

The processor has a pin which receives interrupts.

Whenever an interrupt is received, a piece of code defined by the user is executed. This piece of code is called an interrupt service routine (ISR).

The interrupt has a number which can vary from 0 to 255 and which helps identify the interrupt

There are 3 main applications to interrupts:

-   system calls on both Linux and Windows are called via interrupts generated by user programs via the `int` instruction

-   when a program must wait for some hardware input such as key press, it lets other programs run, and when the keypress is done this generates an interrupt from hardware origin.

    This dispenses the program from periodically checking if the input has finally come or not (pooling) and thus consuming CPU time for nothing.

-   exceptions for error handling

    Certain operations such as division by 0 or trying to access memory without permission generates an interrupt called an exception.

    The exception code allows the programmer to deal with the error.

    Interrupts between 0x0 and 0x1F are reserved for processor exceptions. list: <http://en.wikipedia.org/wiki/Interrupt_descriptor_table>

The instructions which deal with interrupts are:

- `int n`: generate a software interrupt. Used to make system calls.
- `ireX n`: generate interrupt n if flag X is set
- `iret`: return from current ISR to old code

TODO how to register an ISR

TODO check the predefined INT 10 and other predefined ones! <http://en.wikipedia.org/wiki/INT_10H>

## SIMD

Single instruction multiple data.

Do exactly what the name says, for example, 4 multiplications on a single CPU cycle!

It is in general hard to manually port code that was not originally designed to use SIMD instructions and the same goes for compilers.

Introduced later as extensions to the original x86.

Sources:

- <http://en.wikibooks.org/wiki/X86_Assembly/SSE>
- <http://www.songho.ca/misc/sse/sse.html>

MMX, SSE, SSE2, SSE3, SSSE3, SSE4 are the version names

SIMD instructions use the following registers:

- 8 64 bit registers called MMX[0-7]
- 8 128 bit registers called XMM[0-7]
- 1 MXCSR

In this way you can add, subtract, multiply, etc. 4 floats/2 doubles at once without taking into account overheads you can go up to 4x faster.

As all of assembler, you will have a hard time beating modern compiler optimizers with this, so beware... still lots of fun though!

You have to try to align data on 16 bytes to make instructions go faster this is done with the align directive

## Driver IO instructions

The following instructions are used to communicate with hardware such as hard disks mouses and so on.

They cannot be used on user level programs.

- IN: Read from a port
- OUT: Write to a port
- INS/INSB: Input string from port/Input byte string from port
- INS/INSW: Input string from port/Input word string from port
- INS/INSD: Input string from port/Input doubleword string from port
- OUTS/OUTSB: Output string to port/Output byte string to port
- OUTS/OUTSW: Output string to port/Output word string to port
- OUTS/OUTSD: Output string to port/Output doubleword string to port

## Instruction format

## Instruction encoding

How instructions are represented byte by byte.

Vol. 2 Chapter 2.

TODO
